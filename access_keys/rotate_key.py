#!python

"""
# Primary API Doc link
# https://pan.dev/prisma-cloud/api/cspm/get-my-access-keys/

This script is setup for a user to use their credentials to
rotate a service account that they have access to.

The name of the service account which has the keys
--service_account <NAME>

--access_key <ACCESSS KEY UUID>
or
--access_key_csv <RELATIVE PATH TO CSV FILE>
is required. --access_key takes precedent if both are given.

python rotate_keys.py --access_key <access_key>
python rotate_keys.py --access_key_csv <path_to_file>

[X] Check that this works without sys admin permissions. Try with only developer permissions

[X] On delete and create disallow if op is not on a service account

[X] Find what user the access key is assigned to and then find the account type to enforce that
    it is a service account ../service_accounts/list_service_accounts.py

Key Points:
- access key is required via file or argument
- if no service account is given it attempt to use the one that created the existing key
- user is prompted before creation or destruction of keys
- requirements are requests and prismacloud-api
- credentials to run the script can not be updated in that execution
- credentials can be hardcoded, placed in local python file, or passed as cli arguments (see -h)
- "-h" help message is supported to describe arguments
- 90 day expiration can be overriden with a cli argument
- if the key cannot be found it will continue to make a new key for the --service_account
- key can be not found because it's been deleted, user credentials do not allow viewing that key, or the key is incorrect
- --service_account has been tested without quotes and with escaped spaces
- script has been tested with python 3.11 and is expected to work from 3.8>=,<3.12
- username of a user is the mapping to the key's createdBy value
- "My Key" is the default key name if none is given or found
- relative file paths are used and given in relation to CWD when running the script

Questions:
- should the key be printed to the console, file, or both?

Further development:
Ideas could look like prompting the user for
which existing access key to delete in the given service
account and optionally avoiding the delete operation if there
are zero or 1 access keys at the time for that service account.
Besides prompting the user if multiple keys exist then their
keys could be printed with various information about them to
inform a second execution of the script.

"""

import argparse
import json
# import pprint
import requests
from prismacloud.api import pc_api

parser = argparse.ArgumentParser(description="Rotate Prisma access keys.")
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument("--access_key", help="Prisma access key in UUID format")
group.add_argument(
    "--access_key_file",
    type=argparse.FileType("r"),
    required=False,
    help="Path to the access key file generated by Prisma.\nAccess Key ID,********\nSecret Key,********",
)
parser.add_argument(
    "--service_account",
    required=False,
    help="The service account name who's key is being rotated. If blank the access key owner will be used if it is a service account. Access key is required.",
)
parser.add_argument("--expiration_in_days", required=False, default=90)
parser.add_argument("--key_name", default="My Key", required=False, help="Override existing access key name. Default is 'My Key'")
cred_group = parser.add_argument_group()
cred_group.add_argument(
    "--DOMAIN",
    required=False,
    help="https://api.ca.prisma.io for Canada. Will otherwise be required in local creds.py file with DOMAIN variable",
)
cred_group.add_argument(
    "--PRISMA_ACCESS_KEY",
    required=False,
    help="Will otherwise be required in local creds.py file with PRISMA_ACCESS_KEY variable by command `import creds`",
)
cred_group.add_argument(
    "--PRISMA_SECRET_KEY",
    required=False,
    help="Will otherwise be required in local creds.py file with PRISMA_SECRET_KEY variable by command `import creds`",
)
parser.add_argument("--force", required=False, default=False, help="Delete and Create key without prompting.")
parser.add_argument("--new_output_filename", required=False, default="access_key.csv", help="The new access/secret keys will be put into this new file.")
args = parser.parse_args()
key_name = args.key_name

if args.access_key:
    access_key = args.access_key
elif args.access_key_file:
    access_key_file = args.access_key_file
    line = access_key_file.readline()
    access_key = line.split(",")[1].removesuffix("\n")

# ALT user credentials solution
if args.DOMAIN:
    DOMAIN = args.DOMAIN
if args.PRISMA_ACCESS_KEY:
    PRISMA_ACCESS_KEY = args.PRISMA_ACCESS_KEY
if args.PRISMA_SECRET_KEY:
    PRISMA_SECRET_KEY = args.PRISMA_SECRET_KEY

# Settings for Prisma Cloud Enterprise Edition
# import sys, os
# sys.path.append(os.path.abspath(f"../"))
# A file in the same directory called creds_lab.py will be read for these vars
# from creds import PRISMA_ACCESS_KEY, PRISMA_SECRET_KEY, DOMAIN # This is my preferred method. 
# if not args.PRISMA_SECRET_KEY or not args.DOMAIN or not args.PRISMA_ACCESS_KEY:
#     try:
#         import creds_lab
#         DOMAIN =            creds_lab.DOMAIN
#         PRISMA_ACCESS_KEY = creds_lab.PRISMA_ACCESS_KEY
#         PRISMA_SECRET_KEY = creds_lab.PRISMA_SECRET_KEY
#     except ModuleNotFoundError as e:
#         quit(e.msg)

settings = {"url": DOMAIN, "identity": PRISMA_ACCESS_KEY, "secret": PRISMA_SECRET_KEY}

if access_key == args.PRISMA_ACCESS_KEY or settings["identity"] == access_key:
    quit(
        "This script needs user credentials to execute the APIs to update a separate access key"
    )

# os.environ["PRISMA_ACCESS_KEY"] # using an environment variable

pc_api.configure(settings=settings)
payload = ""
headers = {
    "Content-Type": "application/json; charset=UTF-8",
    "Accept": "*/*",
    "x-redlock-auth": pc_api.token,
}

def get_expiration_stamp(days):
    # future_date_utc = datetime(2026, 1, 1, 10, 30, 0)
    # Year, Month, Day, Hour, Minute, Second
    from datetime import datetime, timedelta

    # Get today's date
    current_datetime = datetime.now()

    # Calculate the date 90 days from today
    future_date = current_datetime + timedelta(days=days)
    # The API requires 13 characters in the timestamp so I add a single millisecond.
    # The UI only shows down to the second. Rounding is assumed at this point unconfirmed.
    day = future_date  # datetime(2025, 6, 7, 0, 0, 0, 1)
    timestamp_float = day.timestamp()
    sats = str(timestamp_float).replace(".", "")[:13]  # Get first 13 characters
    return sats

# Get the key name to reuse
url = f"{settings['url']}/access_keys/"
response = requests.request("GET", url, headers=headers, data=payload)
response.raise_for_status()
access_key_list = json.loads(response.text)

# Does the access key given exist
exists = False
for key in access_key_list:
    if key['id'] == access_key:
        exists = True
if not exists:
    print(f"access key {access_key} not found.")
    if not args.service_account:
        quit(f"--service_account is required if access key cannot be looked up.")

# Get user list
url = f"{settings['url']}/v3/user"
response = requests.request("GET", url, headers=headers, data=payload)
try:
    response.raise_for_status()
except requests.exceptions.HTTPError as e:
    if e.response.status_code == 403:
        quit(response.text)
    
user_list = json.loads(response.text)

# Map user to key. Check isServiceAccount
user_key_list = []
found_key = {}
for user in user_list:
    if args.service_account:
        if args.service_account != user["username"]:
            continue
    if user["type"] != "SERVICE_ACCOUNT":
        quit(f"Only service accounts can be used. {args.service_account} is type {user['type']}")
    for key in access_key_list:
        # pprint.pprint(key) # debug
        # user['username'] is the service account name when it's a 
        # service account and user's email otherwise
        if user["username"] == key["createdBy"]:
            print(f"Matched user:key on username {user['username']}")
            user_key_list.append(key)
            if access_key == key['id']:
                # pprint.pprint(user) # debug
                key_name = key["name"]
                found_key = key
                break;

# This assumes that service account can only be changed by creator. SOC creates them
# currently so this may not make sense. 
# if found_key["createdBy"] != args.service_account:
#     quit(f"--service_account {args.service_account} is not the owner of this key")

if key_name == "":
    # Handle no matching key
    if len(user_key_list) == 2:
        quit("This service account already has 2 other access keys which is the limit. Must give a specific key to rotate.")
    res = ""
    if not args.force:
        res = input("access_key seems to be missing. Create new key?\n(y) >>> ")
    # There can only be 2 keys at a time per username
    # username uniquely identifies ownership distinguishing
    # between service accounts and user accounts
    if "y" == res:
        if args.key_name:
            key_name = args.key_name
        else:
            key_name = "My Key"
    else:
        quit()
else:
    # Delete the key by {access_key}
    # Check that error codes make sense for use or parse and print
    if args.force or "y" != input(f"Delete key {access_key}?\n(y) >>> "):
        quit()
    url = f"{settings['url']}/access_keys/{access_key}"
    response = requests.request("DELETE", url, headers=headers, data=payload)
    response.raise_for_status()
    print(f"Deleted status code {response.status_code} {response.text}\n")

# Get expiration date
days_till_expiration = args.expiration_in_days
print(f"Expiration set to {days_till_expiration} days from today")
sats = get_expiration_stamp(days_till_expiration)

if args.service_account:
    service_account_name = args.service_account
else:
    service_account_name = found_key["createdBy"]
payload = json.dumps({"expiresOn": sats, "name": key_name, "serviceAccountName": service_account_name})

# Create access key
url = f"{settings['url']}/access_keys"
response = requests.request("POST", url, headers=headers, data=payload)
response.raise_for_status()

# Parse response and write to file
# The file should be in the format that the UI generates for new keys
js_res = json.loads(response.text)
print(f"New access key {js_res['id']}")
new_file_name = args.new_output_filename
with open(new_file_name, "w") as output:
    output.write(f"Access Key ID,{js_res['id']}\nSecret Key,{js_res['secretKey']}")
print(f"New key/secret written to {new_file_name}")
